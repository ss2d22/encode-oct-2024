{"version":3,"file":"freighter.module.js","sources":["../../src/modules/freighter.module.ts"],"sourcesContent":["import {\n  isConnected,\n  signTransaction,\n  signAuthEntry,\n  requestAccess,\n  signMessage,\n  getNetwork,\n} from '@stellar/freighter-api';\nimport { ModuleInterface, ModuleType } from '../types';\nimport { parseError } from '../utils';\n\nexport const FREIGHTER_ID = 'freighter';\n\nexport class FreighterModule implements ModuleInterface {\n  moduleType: ModuleType = ModuleType.HOT_WALLET;\n\n  productId: string = FREIGHTER_ID;\n  productName: string = 'Freighter';\n  productUrl: string = 'https://freighter.app';\n  productIcon: string = 'https://stellar.creit.tech/wallet-icons/freighter.png';\n\n  async runChecks(): Promise<void> {\n    if (!(await this.isAvailable())) {\n      throw new Error('Freighter is not connected');\n    }\n  }\n\n  async isAvailable(): Promise<boolean> {\n    return isConnected()\n      .then(({ isConnected, error }) => !error && isConnected)\n      .catch((): boolean => false);\n  }\n\n  async getAddress(): Promise<{ address: string }> {\n    return this.runChecks()\n      .then(() => requestAccess())\n      .then(({ address, error }) => {\n        if (error) throw error;\n\n        return { address };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n\n  async signTransaction(\n    xdr: string,\n    opts?: {\n      networkPassphrase?: string;\n      address?: string;\n      path?: string;\n      submit?: boolean;\n      submitUrl?: string;\n    }\n  ): Promise<{ signedTxXdr: string; signerAddress?: string }> {\n    return this.runChecks()\n      .then(async () => {\n        const { signedTxXdr, signerAddress, error } = await signTransaction(xdr, {\n          address: opts?.address,\n          networkPassphrase: opts?.networkPassphrase,\n        });\n\n        if (error) throw error;\n\n        return { signedTxXdr, signerAddress: signerAddress };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n\n  async signAuthEntry(\n    authEntry: string,\n    opts?: {\n      networkPassphrase?: string;\n      address?: string;\n      path?: string;\n    }\n  ): Promise<{ signedAuthEntry: string; signerAddress?: string }> {\n    return this.runChecks()\n      .then(async () => {\n        const { signedAuthEntry, signerAddress, error } = await signAuthEntry(authEntry, {\n          address: opts?.address,\n          networkPassphrase: opts?.networkPassphrase,\n        });\n\n        if (error || !signedAuthEntry) throw error;\n\n        return { signedAuthEntry: signedAuthEntry.toString('base64'), signerAddress: signerAddress };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n\n  async signMessage(\n    message: string,\n    opts?: {\n      networkPassphrase?: string;\n      address?: string;\n      path?: string;\n    }\n  ): Promise<{ signedMessage: string; signerAddress?: string }> {\n    return this.runChecks()\n      .then(async () => {\n        const { signedMessage, signerAddress, error } = await signMessage(message, {\n          address: opts?.address,\n          networkPassphrase: opts?.networkPassphrase,\n        });\n\n        if (error || !signedMessage) throw error;\n\n        return { signedMessage: signedMessage.toString('base64'), signerAddress: signerAddress };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n\n  async getNetwork(): Promise<{ network: string; networkPassphrase: string }> {\n    return this.runChecks()\n      .then(async () => {\n        const { network, networkPassphrase, error } = await getNetwork();\n\n        if (error) throw error;\n\n        return { network, networkPassphrase };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n}\n"],"names":["FREIGHTER_ID","FreighterModule","constructor","this","moduleType","ModuleType","HOT_WALLET","productId","productName","productUrl","productIcon","runChecks","isAvailable","Error","isConnected","then","error","catch","getAddress","requestAccess","address","e","parseError","signTransaction","xdr","opts","async","signedTxXdr","signerAddress","networkPassphrase","signAuthEntry","authEntry","signedAuthEntry","toString","signMessage","message","signedMessage","getNetwork","network"],"mappings":"mOAWO,MAAMA,EAAe,YAErB,MAAMC,EAAN,WAAAC,GACLC,KAAAC,WAAyBC,EAAWC,WAEhBH,KAAAI,UAAAP,EACEG,KAAAK,YAAA,YACDL,KAAAM,WAAA,wBACCN,KAAAO,YAAA,uDAAA,CAEtB,eAAMC,GACJ,UAAYR,KAAKS,cACT,MAAA,IAAIC,MAAM,6BAEpB,CAEA,iBAAMD,GACJ,OAAOE,IACJC,MAAK,EAAGD,YAAAA,EAAaE,YAAaA,GAASF,IAC3CG,OAAM,KAAe,GAC1B,CAEA,gBAAMC,GACJ,OAAOf,KAAKQ,YACTI,MAAK,IAAMI,MACXJ,MAAK,EAAGK,UAASJ,YAChB,GAAIA,EAAa,MAAAA,EAEjB,MAAO,CAAEI,UAAQ,IAElBH,OAAWI,IACV,MAAMC,EAAWD,EAAC,GAExB,CAEA,qBAAME,CACJC,EACAC,GAQA,OAAOtB,KAAKQ,YACTI,MAAKW,UACJ,MAAMC,YAAEA,EAAaC,cAAAA,EAAAZ,MAAeA,SAAgBO,EAAgBC,EAAK,CACvEJ,QAASK,GAAML,QACfS,kBAAmBJ,GAAMI,oBAG3B,GAAIb,EAAa,MAAAA,EAEV,MAAA,CAAEW,cAAaC,gBAA6B,IAEpDX,OAAWI,IACV,MAAMC,EAAWD,EAAC,GAExB,CAEA,mBAAMS,CACJC,EACAN,GAMA,OAAOtB,KAAKQ,YACTI,MAAKW,UACJ,MAAMM,gBAAEA,EAAiBJ,cAAAA,EAAAZ,MAAeA,SAAgBc,EAAcC,EAAW,CAC/EX,QAASK,GAAML,QACfS,kBAAmBJ,GAAMI,oBAGvB,GAAAb,IAAUgB,EAAuB,MAAAhB,EAErC,MAAO,CAAEgB,gBAAiBA,EAAgBC,SAAS,UAAWL,gBAA6B,IAE5FX,OAAWI,IACV,MAAMC,EAAWD,EAAC,GAExB,CAEA,iBAAMa,CACJC,EACAV,GAMA,OAAOtB,KAAKQ,YACTI,MAAKW,UACJ,MAAMU,cAAEA,EAAeR,cAAAA,EAAAZ,MAAeA,SAAgBkB,EAAYC,EAAS,CACzEf,QAASK,GAAML,QACfS,kBAAmBJ,GAAMI,oBAGvB,GAAAb,IAAUoB,EAAqB,MAAApB,EAEnC,MAAO,CAAEoB,cAAeA,EAAcH,SAAS,UAAWL,gBAA6B,IAExFX,OAAWI,IACV,MAAMC,EAAWD,EAAC,GAExB,CAEA,gBAAMgB,GACJ,OAAOlC,KAAKQ,YACTI,MAAKW,UACJ,MAAMY,QAAEA,EAAST,kBAAAA,EAAAb,MAAmBA,SAAgBqB,IAEpD,GAAIrB,EAAa,MAAAA,EAEV,MAAA,CAAEsB,UAAST,oBAAkB,IAErCZ,OAAWI,IACV,MAAMC,EAAWD,EAAC,GAExB"}